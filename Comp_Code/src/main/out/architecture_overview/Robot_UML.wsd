@startuml
allowmixing
package Main_java {
    Class Main {
        +main(String... args)
    }

    note left of Main #SkyBlue
    Main is the
    starting Java Class
    end note
}
Class RobotBase #LightGray{
    -setupCameraServerShared()
    -setupMathShared()
    #RobotBase()
    +getRuntimeType()
    +isStimulation()
    +isReal()
    +isDisabled()
    +isEnabled()
    +isAutonomous()
    +isAutonomousEnabled()
    +isTest()
    +isTestEnabled()
    +isTeleop()
    +isTeleopEnabled()
    -runRobot()
}

Main -down-> RobotBase

note left of RobotBase #SkyBlue
    This Class provides 
    status updates 
    and the startRobot method,
    which creates a new Robot Class.
end note

Class Robot {
    ..Components..
    -m_robotContainer: RobotContainer  
}

Main -down-> Robot

note left of Robot #SkyBlue
    The Robot Class is
    a TimedRobot and is
    created in Main.
    Primary function is to 
    create the RobotContainer
    object and starting the 
    DataLogManager.
end note

package "TimedRobot" {
Class TimedRobot #LightGray{
    +startCompetition()
    +addPeriodic(Runnable callback, Time period, Time offset)
    ..IterativeRobotBase..
    +robotPeriodic():void
    +disabledInit():void
    +disabledPeriodic():void
    +disabledExit():void
    +autonomousInit():void
    +autonomousPeriodic():void
    +autonomousExit():void
    +teleopInit():void
    +teleopPeriodic():void
    +teleopExit():void
    +testInit():void
    +testPeriodic():void
    +testExit():void
    +simulationInit():void
    +simulationPeriodic():void
    +simulationExit():void

}
TimedRobot <|-- Robot
note right of TimedRobot #SkyBlue
    The TimedRobot Class is an extension
    of the IterativeRobotBase Class that
    contains many of the base robot functions.
end note
}

package Robotcontainer{
    Class RobotContainer{
        ..Subsystems..
        -m_intakeSubsystem: IntakeSubsystem
        -m_popper: Popper
        -m_elevatorSubsystem: ElevatorSubsystem
        -m_driveTrain: DriveTrain
        -m_leds: LedSubsystem
        ..Input Devices..
        -m_driverController: CommandXboxController
        -m_operatorController: CommandXboxController
        ..Commands for Autos..
        +L3 Raise: NamedCommands
        +L2 Raise: NamedCommands
        +L2 Algea Prep: NamedCommands
        +Stow Popper: NamedCommands
        +L2 Algea: NamedCommands
        +L3 Algea: NamedCommands
        +Load: NamedCommands
        +autoIntake: NamedCommands
        +autoScore: NamedCommands
        ..Methods..
        -configureBindings():void
        +getAutonomousCommand():Command

    }
    Robot -right-> RobotContainer #line.dashed

    note left of RobotContainer #SkyBlue
        The RobotContainer Class defines the subsystem Classes.
        This Class also declares the controller Classes 
        and button and trigger Classes. A private method
        binds controller Classes to Subsystem methods in
        the form of Command Classes or lambda functions. 
        Commands are also added to the NamedCommands class here.
        The NamedCommands Class makes commands available to 
        autonomous routines.
    end note
}
package Intake {
    Class IntakeSubsystem{
        ..Components..
        -intakeMotor: SparkMax
        -sensor: DigitalInput
        -hasCoral: boolean
        ..Methods..
        +stopIntake():void
        +startIntake(double):void
        +detectCoral():boolean
        +periodic():void
        +simulationPeriodic():void
    }
    RobotContainer -down-> IntakeSubsystem #line.dashed

    note left of IntakeSubsystem #SkyBlue
        The IntakeSubsystem Class is a SubsystemBase
        Class that is responsible for defining
        the hardware of the Intake function,
        defining methods controlling that hardware and
        coordinating the scheduling of commands using
        the subsystem hardware.
    end note
}
package Popper {
    Class PopperSubsystem{
        ..Components..
        -Rotator: TalonFX
        -Spinner: SparkMax
        -intakeArmEncoder: Encoder
        +armOffset:double
        -m_motmag:MotionMagicVoltage    
        ..Methods..
        +PopperMove(double):void
        +getPopperPosition():double
        +setPopperPosition(double):void
        +zeroArm():void
        +setPopperState(popperState):void
        +PopperSpinL3():void
        +PopperSpinL2():void
        +PopperSpinStop():void
        +updatePosition():void
        +getGoalPosition():double
        +periodic():void
        +simulationPeriodic():
    }
    RobotContainer -down-> PopperSubsystem #line.dashed

    enum popperState #LightCoral{
        Start
        L2
        L2Plus
        L3
        L3Plus
        }
    popperState -left-> PopperSubsystem

    note left of PopperSubsystem #SkyBlue
        The Popper Class is a SubsystemBase
        Class that is responsible for defining
        the hardware of the Algea removal function,
        defining methods controlling that hardware and
        coordinating the scheduling of commands using
        the subsystem hardware.
    end note
}


package Elevator {
    Class ElevatorSubsystem{
        ..Components..
        -elevatorMotor: TalonFX
        -limitSwitch: DigitalInput
        -currentState: elevatorState
        m_motmag:MotionMagicVoltage    
        ..Methods..
        +stopElevator():void
        +runElevator(double):void
        +getSensor():boolean
        +zeroEncoders():void
        +getPosition(double):void
        +setPosition(double):void
        +setState(elevatorState):void
        +getGoalPosition():double
        +periodic():void
        +simulationPeriodic():
    }

    RobotContainer -down-> ElevatorSubsystem #line.dashed

    enum elevatorState #LightCoral{
        Start
        L1
        L2
        L3
        Load
        }

    elevatorState -left-> ElevatorSubsystem

    note left of ElevatorSubsystem #SkyBlue
        The ElevatorSubsystem Class is a SubsystemBase
        Class that is responsible for defining
        the hardware of the Elevator function,
        defining methods controlling that hardware and
        coordinating the scheduling of commands using
        the subsystem hardware.
    end note
}

package Drivetrain {
    Class DriveTrain{
        ..Components..
        -swerveDrive: SwerveDrive
        -aprilTagFieldLayout: AprilTagFieldLayout
        -vision: Vision
        ..Methods..
        +getTargetSpeeds(double, double, double, double): ChassisSpeeds
        +getTargetSpeeds(double, double, Rotation2d): ChassisSpeeds
        --Takes the inputs from the move and rotate sticks.
        +getHeading():Rotation2d
        +getPose2d():Pose2d
        +drive(Translate2d, double, boolean, boolean):void
        +drive(Translate2d, double, boolean):void
        +getFieldVelocity(): ChassisSpeeds
        +getRobotVelocity(): ChassisSpeeds
        +getSwerveDriveConfiguration(): SwerveDriveConfiguration
        +setupPhotonVision():void
        +setupPathPlanner():void
        +resetPose(Pose2d):void
        +DriveToPoint(Pose2d): Command
        +driveToPose(Pose2d): Command
        +isRedAlliance():boolean
        +zeroGyroWithAlliance():void
        +zeroGyro():void
        +setMotorBrake(boolean):void
        +periodic():void
        +simulationPeriodic():void
    }

    RobotContainer -down-> DriveTrain #line.dashed

    note left of DriveTrain #SkyBlue
        The DriveTrain Class is a SubsystemBase
        Class that is responsible for defining
        the hardware of the Drivetrain function,
        defining methods controlling that hardware and
        coordinating the scheduling of commands using
        the subsystem hardware.
        This class also creates the Vision Class and 
        is responsible for odometry classes.
    end note

    package VisionSubSystem #LightGrey{
        Class Vision{
            ..Components..
            +fieldLayout:AprilTagFieldLayout
            +visionSim: VisionSystemSim
            -visionTroubleShoot:boolean
            -currentPose:Pose2d
            ..Camera Level Atributes..
            +latencyAlert:Alert
            +camera:PhotonCamera
            +poseEstimator:PhotonPoseEstimator
            -singleTagStdDevs:Matrix<N3, N1>
            -multiTagStdDevs:Matrix<N3, N1>
            -robotToCamTransform:Transform3d
            +curStdDecs:Matrix<N3, N1>
            +estimatedRobotPose:Optional<EstimatedRobotPose>
            +cameraSim:PhotonCameraSim
            +resultsList:List<PhotonPipelineResult>
            -lastReadTimeStamp:double
            ..Camera Level Methods..
            +addToVisionSim(VisionSystemSim):void
            +getBestResult():Optional<PhotonPipelineResult>
            +getLatestResult():Optional<PhotonPipelineResult>
            +getEstimatedGlobalPose():Optional<EstimatedRobotPose>
            -updateUnreadResults():void
            -updateEstimatedGlobalPose():void
            -updateEstimationStdDevs(Optional<EstimatedRobotPose>,List<PhotonTrackedTarget>):void
            ..Methods..
            +getAprilTagPose(int, Transform2d):Pose2d
            +updatePoseEstimation(SwerveDrive):void
            +getEstimatedGlobalPose():Optional<EstimatedRobotPose>
            +getDistanceFromAprilTag(int):double
            +getTargetFromId(int, Cameras):PhotonTrackedTarget
            +getVisionSim():VisionSystemSim
            +openSimCameraViews():void
            +periodic():void
            +simulationPeriodic():void
        }

        Vision <-up- DriveTrain #line.dashed

        note left of Vision #SkyBlue
            The Vision Class is a SubsystemBase
            Class that is responsible for defining
            the hardware of the Vision function,
            defining methods controlling that hardware and
            coordinating the scheduling of commands using
            the subsystem hardware.
            Works closely with the DriveTrain to determine 
            robot position.
        end note

        enum Cameras #LightCoral{
            FRONT_CAM
            REAR_CAM
        }
        Cameras -left-> Vision

        note right of Cameras #SeaGreen
            This enum includes Camera objects and
            is part of the Vision subsystem
        end note
    }
}

package LED {
    
    Class LedSubsystem{
        ..Components..
        -led:AddressableLED
        -ledSim:AddressableLEDSim
        -ledBuffer:AddressableLEDBuffer
        -currentState:LedState
        -ledRainbowOffset:double
        ..Methods..
        +ledStateToString(LedState):String
        setAllLeds(Color):void
        setLedRange(int, int, Color):void
        rainbow():void
        +updateLed(LedState):void
        +getState():LedState
        +setState(LedState):void
        +periodic():void
        +simulationPeriodic():void
    }
    RobotContainer -down-> LedSubsystem #line.dashed

    note left of LedSubsystem #SkyBlue
        The LedSubsytem Class is a BaseSubsystem
        containing the hardware and methods
        controlling the LEDs on the robot
    end note

    enum LedState #LightCoral{
        Idle,
        RunningIntake,
        HasCoral,
        PerparingToShoot,
        ReadyToShoot,
        Pride
    }
    LedState -left-> LedSubsystem

    note right of LedState #SeaGreen
        This LedState enum is a list
        of possible LedSubsystem states
    end note
}

Class SubsystemBase #LightGray{
    +getName():String
    +setDefaultCommand(Command):void
    +periodic():void
    +simulationPeriodic():void
    +runOnce(Runnable):Command
    +run(Runnable):Command
    +startEnd(Runnable, Runnable):Command
    +runEnd(Runnable, Runnable):Command
    +startRun(Runnable, Runnable):Command
    +defer(Supplier<Command>):Command
}
SubsystemBase <|-down- IntakeSubsystem
SubsystemBase <|-down- PopperSubsystem
SubsystemBase <|-down- ElevatorSubsystem
SubsystemBase <|-down- DriveTrain
SubsystemBase <|-down- LedSubsystem


package Driverstation {
    Class DriverStation #LightGray{
        ..Components..
        +{static}kJoystickPorts:int
        ..Methods..
        +{static}reportError(String, boolean):void
        +{static}reportWarning(String, boolean):void
        +{static}getStickButton(int, int):boolean
        +{static}getStickButtonPressed(int, int):boolean
        +{static}getStickButtonReleased(int, int):boolean
        +{static}getStickAxis(int, int):double
        +{static}getStickPOV(int, int):int
        +{static}getJoystickIsXbox(int):boolean
        +{static}getJoystickName(int):String
        +{static}isEnabled():boolean
        +{static}isDisabled():boolean
        +{static}isEStopped():boolean
        +{static}isAutonomous():boolean
        +{static}isTeleop():boolean
        +{static}isTest():boolean
        +{static}getGameSpecificMessage:String
        +{static}getEventName:String
        +{static}getMatchType():MatchType
        +{static}getMatchNumber():int
        +{static}getAlliance():Optional<Alliance>
        +{static}getLocation():OptionalInt
        +{static}waitForDsConnection(double):boolean
        +{static}getMatchTime():double
        +{static}silenceJoystickConnectionWarning(boolean):void
        +{static}refreshData():void
        +{static}startDataLog(DataLog, boolean):void
    }
    DriverStation --> RobotContainer #line.dashed

    Class MatchDataSender #LightGray{
        ..Atributes..
        -gameSpecificMessage:StringPublisher
        -eventName:StringPublisher
        -matchNumber:IntegerPublisher
        -replayNumber:IntegerPublisher
        -alliance:BooleanPublisher
        -station:IntegerPublisher
        -controlWord:IntegerPublisher
        ..Methods..
        sendMatchData():void
    }
    MatchDataSender --> DriverStation #line.dashed

    Class JoystickLogSender #LightGray{
        -log:DataLog
        -stick:int
        -timestamp:long
        ..Methods..
        +send(long):void
        +appendButtons(HALJoystickButtons, long):void
        +appendAxes(HALJoystickAxes, long):void
        +appendPOVs(HALJoystickOVs, long):void
    }
    JoystickLogSender --> DriverStation #line.dashed

    enum Alliance #LightCoral{
        Red
        Blue
    }
    Alliance -right-> DriverStation

    enum MatchType #LightCoral{
        None
        Practice
        Qualification
        Elimination
    }
    MatchType -left-> DriverStation
}
'These are Constant Sub-Objects
package Constants #LightGoldenRodYellow{

    Class Swerve_Constants #LightGoldenRodYellow{
        +{static}MAX_SPEED:double
        +{static}LOOP_TIME:double
        +{static}ROBOT_MASS:double
        +{static}CHASSIS:Matter
    }

    Class OperatorConstants #LightGoldenRodYellow{
        +{static}kDriverControllerPort:int
        +{static}kOperatorConstants:int
    }

    Class Intake_Constants #LightGoldenRodYellow{
        +{static}motorId:int
        +{static}sensorId:int
    }

    Class Elevator_Constants #LightGoldenRodYellow{
        +{static}elevatorMotorId:int
        +{static}sensorId:int
        +{static}holdValue:double
        +{static}threshold:double
        +{static}Start_Position:double
        +{static}L1_Position:double
        +{static}Load_Position:double
        +{static}L2_Position:double
        +{static}L3_Position:double
        +{static}Position_Error:double
    }

    Class Popper_Constants #LightGoldenRodYellow{
        +{static}popperRotateID:int
        +{static}popperSpinnerID:int
        +{static}popperEncoderChannelA:int
        +{static}popperEncoderChannelB:int
        +{static}Start_Position:double
        +{static}L2_Position:double
        +{static}L2Plus_Position:double
        +{static}L3_Position:double
        +{static}L3Plus_Position:double
        +{static}popperSpinnerSpeed:double
        +{static}minAngle:double
        +{static}maxAngle:double
        +{static}PopperStep:double
        +{static}maxPosition:double
        +{static}minPosition:double
        +{static}Position_Error:double
    }

    Class Led #LightGoldenRodYellow{
        +{static}numLeds:int
        +{static}ledPwm:int
        +{static}rainbowShiftSpeed:double
    }

    RobotContainer .[#Blue,thickness=2].> Constants 
    DriveTrain .[#Blue,thickness=2].> Constants 
    ElevatorSubsystem .[#Blue,thickness=2].> Constants 
    IntakeSubsystem .[#Blue,thickness=2].> Constants 
    LedSubsystem .[#Blue,thickness=2].> Constants 
    Popper .[#Blue,thickness=2].> Constants 

    Constants --> Swerve_Constants
    Constants --> OperatorConstants
    Constants --> Elevator_Constants
    Constants --> Popper_Constants
    Constants --> Intake_Constants 

    Constants --> Led
}

Class Command #LightGray{
    +initialize():void
    +execute():void
    +end():void
    +isFinished():boolean
    +getRequirements():Set<Subsystem>
    +addRequirements(Subsystem):void
    +withTimeout(double):ParallelRaceGroup
    +until(BooleanSupplier):ParallelRaceGroup
    +onlyWhile(BooleanSupplier):ParallelRaceGroup
    +beforeStarting(Runnable/Command, Subsystem):SequentialCommandGroup
    +andThen(Runnable, Subsystem):SequentialCommandGroup
    +withDeadline(Command):ParallelDeadlineGroup
    +alongWith(Command):ParallelCommandGroup
    +raceWith(Command):ParallelRaceGroup
    +repeatedly():RepeatCommand
    +unless(BooleanSupplier):ConditionalCommand
    +onlyIf(BooleanSupplier):ConditionalCommand
    +ignoringDisable(boolean):WrapperCommand

}

Class CommandScheduler #LightGray{
    -{static}instance:CommandScheduler
    -m_scheduledCommands:Set<Command>
    -m_requirements:Map<SubSystem, Command>
    -m_activetButtonLoop:EventLoop
    ..Methods..
    -schedule(Command):void
    +run():void
    +registerSubsystem(Subsystem):void
    +setDefaultCommand(Subsystem, Command):void
    +getDefaultCommand(Subsystem):Command
    +cancel(Command):void

}

Robot --> CommandScheduler #line.dashed

note left of CommandScheduler #SkyBlue
    The CommandSchedule is responsible for
    collecting the actions from Commands.
    Either from Command objects or instant 
    commands. 
end note

Class AbsoluteFieldDrive{
    -swerve:DriveTrain
    -vX:DoubleSupplier
    -vY:DoubleSupplier
    -hX:DoubleSupplier
    -hY:DoubleSupplier
    -relativeToField:BooleanSupplier
    ..methods..
    +execute():void

}



actor Operator #Green

Operator -[#Green]-> DriverStation

AbsoluteFieldDrive -up-|> Command
RobotContainer --> AbsoluteFieldDrive #line.dashed
AbsoluteFieldDrive --> DriveTrain
DriverStation -[#Green]-> AbsoluteFieldDrive
AbsoluteFieldDrive -[#Green]-> CommandScheduler
note right of AbsoluteFieldDrive #SkyBlue
    The AbsoluteFieldDrive Class 
    is a Command Class that requires
    a subsystem.
end note



@enduml